g=c(0,0,0,1,1,1,2,2,2,2,2)
logl=matrix(0,11,1024)
for(i in 1:11){
logl[i,]=baseline+g[i]*effect
}
plot(logl[1,])
plot(logl[3,])
plot(logl[5,])
plot(logl[10,])
simdata=rpois(11*1024,logl)
plot(simdata[1,])
simdata=matrix(rpois(11*1024,logl),11,1024)
simdata[1,]
plot(simdata[1,])
plot(simdata[6,])
plot(simdata[9,])
tt=multiseq(simdata,g,lm.approx=TRUE)
library(multiseq)
tt=multiseq(simdata,g,lm.approx=TRUE)
plot(tt$baseline.mean)
plot(tt$effect.mean)
plot(tt$effect.mean,type='l')
plot(tt$baseline.mean,type='l')
plot(exp(tt$baseline.mean),type='l')
plot(exp(tt$effect.mean),type='l')
tt=multiseq(simdata,g,lm.approx=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=TRUE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=TRUE,baseline="grp")
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=TRUE,baseline="inter")
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,repara=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,repara=TRUE)
plot(tt$baseline.mean,type='l')
g=c(0,0,0,1,1,1)
logl=matrix(0,6,1024)
for(i in 1:6){
logl[i,]=baseline+g[i]*effect
}
simdata=matrix(rpois(6*1024,logl),6,1024)
tt=multiseq(simdata,g,repara=TRUE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,lm.approx=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,lm.approx=TRUE)
plot(tt$baseline.mean,type='l')
log(0.01)
spike.f=function(x) (0.75*exp(-500*(x-0.23)^2)+1.5*exp(-2000*(x-0.33)^2)+3*exp(-8000*(x-0.47)^2)+2.25*exp(-16000*(x-0.69)^2)+0.5*exp(-32000*(x-0.83)^2))
#spike.f=function(x) (0.75*exp(-500*(x-0.23)^2)+1.5*exp(-1000*(x-0.33)^2)+3*exp(-500*(x-0.47)^2)+2.25*exp(-500*(x-0.69)^2)+0.5*exp(-500*(x-0.83)^2))
n=1024
xgrid=1:n/n
mu.s=spike.f(1:n/n)
mu.s0=1
set.seed(415)
X.s=rpois(n,mu.s0*(0.02+mu.s))
set.seed(527)
X.ss=rpois(n,mu.s0*(0.02+mu.s))
mse=function(x,y) mean((x-y)^2)
n=length(X.s)
J=log2(n)
mu.s0=2
set.seed(415)
X.s1=rpois(n,mu.s0*(0.02+mu.s))
mu.s0=3
set.seed(415)
X.s2=rpois(n,mu.s0*(0.02+mu.s))
mu.s0=4
set.seed(415)
X.s3=rpois(n,mu.s0*(0.02+mu.s))
set.seed(604)
X.test=rpois(1024,5*(0.5+mu.s))
set.seed(519)
X.s4=rpois(n,1*(0.02+c(mu.s[-(1:100)],mu.s[1:100])))
set.seed(601)
X.s5=rpois(n,1*(0.02+c(mu.s[-(1:200)],mu.s[1:200])))
X.s6=(X.s+X.s5)/2
X=rbind(X.s,X.s4)
library(smash)
tb=ashsmooth.pois(X[1,])
plot(tb,type='l')
X[1,]
tb=ashsmooth.pois(X.s)
plot(tb,type='l')
X.s
mu.s0*(0.02+mu.s)
?dt
287/5+121/5-15
287/5+121/5-15+8
library(centipede)
library(CENTIPEDE)
data(NRSFcuts, package='CENTIPEDE')
data(NRSF_Anno, package='CENTIPEDE')
dim(NRSFcuts)
dim(NRSF_Anno)
head(NRSF_Anno)
head(NRSFcuts)
0.6*90
54+6+61
54+66+61
23277*1.45
25000*1.45
30000*1.45
28000*1.45
29000+160*18
3880*1.45
3880*1.45
31880*1.45
338880*1.45
33880*1.45
29300*1.45
32300*1.45
34300*1.45
49700-33000
4800-33000
46800-33000
2000/30000
2500/40000
tt = matrix(c(2,0,2,0,2,0),nr=3)
tt
tt = matrix(c(2,0,2,0,2,0,1,0,2,0,3,0),nr=3)
tt
tt = matrix(c(2,0,2,0,2,0,1,0,2,0,3,0),nr=6)
ttt
tt
zero.ind = rowSums(tt) == 0
zero.ind
tt[zero.ind, ]
tt[zero.ind, ] = 1:2
tt
tt[zero.ind, ]
tt = matrix(c(2,0,2,0,2,0,1,0,2,0,3,0),nr=6)
tt
zero.ind = rowSums(tt) == 0
zero.ind
tt[zero.ind, ]
tt[zero.ind, ] = matrix(rep(1:2, length(zero.ind)), yrow=TRUE, nr = length(zero.ind))
tt[zero.ind, ] = matrix(rep(1:2, length(zero.ind)), byrow=TRUE, nr = length(zero.ind))
matrix(rep(1:2, length(zero.ind)), byrow=TRUE, nr = length(zero.ind))
length(zero.ind)
tt = matrix(c(2,0,2,0,2,0,1,0,2,0,3,0),nr=6)
tt
zero.ind = rowSums(tt) == 0
zero.ind
tt[zero.ind, ] = matrix(rep(1:2, sum(zero.ind)), byrow=TRUE, nr = sum(zero.ind))
tt
library(multiseq)
titable
parentTitable
multiseq::parentTitable
multiseq::ParentTitable
multiseq::ParentTItable
multiseq::parentTItable
ParentTItable
multiseq::ParentTItable
library(smash)
ParentTItable
titable
smash::titable
titable=function(sig){
n = length(sig)
J = log2(n)
dmat = matrix(0, nrow=J+1, ncol=n)
ddmat = matrix(0, nrow=J+1, ncol=n)
dmat[1,] = sig
ddmat[1,] = sig
#dmat[1,] = as.matrix(sig)
#dmat2 = matrix(0, nrow=J, ncol=2*n) #the parent table
for(D in 0:(J-1)){
nD = 2^(J-D);
nDo2 = nD/2;
twonD = 2*nD;
for(l in 0:(2^D-1)){
ind = (l*nD+1):((l+1)*nD)
#ind2 = (l*twonD+1):((l+1)*twonD)
x = dmat[D+1,ind]
lsumx = x[seq(from=1,to=nD-1, by=2)] + x[seq(from=2,to=nD,by=2)]
ldiffx = x[seq(from=1,to=nD-1, by=2)] - x[seq(from=2,to=nD,by=2)]
rx = rshift(x);
rsumx = rx[seq(from=1,to=nD-1, by=2)] + rx[seq(from=2,to=nD,by=2)]
rdiffx = rx[seq(from=1,to=nD-1, by=2)] - rx[seq(from=2,to=nD,by=2)]
dmat[D+2,ind] = c(lsumx,rsumx)
ddmat[D+2,ind] = c(ldiffx,rdiffx)
}
}
return(list(sumtable=dmat,difftable=ddmat))
}
titable(1:8)
interleave=function(x,y){
return(as.vector(rbind(x,y)))
}
#' Shift a vector one unit to the right
#' @param x: a vector
#' @return a vector of the same length as that of x
rshift = function(x){L=length(x); return(c(x[L],x[-L]))}
lshift = function(x){return(c(x[-1],x[1]))}
titable(1:8)
ParentTItable=function(sig){
n = length(sig)
J = log2(n)
dmat = matrix(0, nrow=J+1, ncol=n)
dmat[1,] = sig
#dmat[1,] = as.matrix(sig)
dmat2 = matrix(0, nrow=J, ncol=2*n) #the parent table
for(D in 0:(J-1)){
nD = 2^(J-D);
nDo2 = nD/2;
twonD = 2*nD;
for(l in 0:(2^D-1)){
ind = (l*nD+1):((l+1)*nD)
ind2 = (l*twonD+1):((l+1)*twonD)
x = dmat[D+1,ind]
lsumx = x[seq(from=1,to=nD-1, by=2)] + x[seq(from=2,to=nD,by=2)]
rx = rshift(x);
rsumx = rx[seq(from=1,to=nD-1, by=2)] + rx[seq(from=2,to=nD,by=2)]
dmat[D+2,ind] = c(lsumx,rsumx)
dmat2[D+1,ind2] = c(x,rx)
}
}
return(list(TItable=dmat,parent=dmat2))
}
ParentTItable(1:8)
512-255
25+512
257+512
1024+512-255
1281+512
3841:4352 - 3584
#' Interleave two vectors.
#' @keywords internal
interleave=function(x,y){
return(as.vector(rbind(x,y)))
}
#' Shift a vector right and left respectively.
#' @keywords internal
rshift = function(x){L=length(x); return(c(x[L],x[-L]))}
lshift = function(x){return(c(x[-1],x[1]))}
#' Create a TI table and a parent table.
#'
#' This function returns both a TItable and a "parent" table whose pairwise comparisons are used to create a TI table. For example, in the ith row, elements 1, 2 are the parents of the first element in the (i+1)th row of the TI table.
#'
#' This function creates a decomposition table of signal, using pairwise sums, keeping just the values that are *not* redundant under the shift-invariant scheme.
#'
#' @param sig: an n vector of Poisson counts at n locations
#' @return a list with elements "TItable" and "parent"
#' @references This is very similar to TI-tables in Donoho and Coifman's TI-denoising framework
#' @keywords internal
ParentTItable=function(sig){
n = length(sig)
J = log2(n)
dmat = matrix(0, nrow=J+1, ncol=n)
dmat[1,] = sig
#dmat[1,] = as.matrix(sig)
dmat2 = matrix(0, nrow=J, ncol=2*n) #the parent table
for(D in 0:(J-1)){
nD = 2^(J-D);
nDo2 = nD/2;
twonD = 2*nD;
for(l in 0:(2^D-1)){
ind = (l*nD+1):((l+1)*nD)
ind2 = (l*twonD+1):((l+1)*twonD)
x = dmat[D+1,ind]
lsumx = x[seq(from=1,to=nD-1, by=2)] + x[seq(from=2,to=nD,by=2)]
rx = rshift(x);
rsumx = rx[seq(from=1,to=nD-1, by=2)] + rx[seq(from=2,to=nD,by=2)]
dmat[D+2,ind] = c(lsumx,rsumx)
dmat2[D+1,ind2] = c(x,rx)
}
}
return(list(TItable=dmat,parent=dmat2))
}
ParentTItable(1:4)
library(multiseq)
x.1 = rpois(n, mu.s)
n=1024
t=1:n/n
spike.f=function(x) (0.75*exp(-500*(x-0.23)^2)+1.5*exp(-2000*(x-0.33)^2)+3*exp(-8000*(x-0.47)^2)+2.25*exp(-16000*(x-0.69)^2)+0.5*exp(-32000*(x-0.83)^2))
mu.s=spike.f(t)
x.1 = rpois(n, mu.s)
plot(x.1)
x.1 = matrix(rpois(10*n, mu.s), nr = 10, byrow = TRUE)
plot(x.1[1,])
x.1 = matrix(rpois(10*n, mu.s), nr = 10, byrow = TRUE)
x.2 = matrix(rpois(10*n, 3*mu.s), nr = 10, byrow = TRUE)
x = rbind(x.1, x.2)
g = rep(0:1, each = 10)
res = multiseq(x, g)
plot(res$effect.mean, type = 'l')
plot(exp(res$effect.mean), type = 'l')
x.1 = matrix(rpois(10*n, mu.s), nr = 10, byrow = TRUE)
x.2 = matrix(rpois(10*n, mu.s), nr = 10, byrow = TRUE)
x = rbind(x.1, x.2)
g = rep(0:1, each = 10)
res = multiseq(x, g)
plot(res$effect.mean, type = 'l')
x.1 = matrix(rpois(10*n, mu.s), nr = 10, byrow = TRUE)
x.2 = matrix(rpois(10*n, 3*mu.s), nr = 10, byrow = TRUE)
x = rbind(x.1, x.2)
res = multiseq(x, g)
plot(res$effect.mean, type = 'l')
plot(mu.s)
x.1 = matrix(rpois(10*n, 0.01+mu.s), nr = 10, byrow = TRUE)
x.2 = matrix(rpois(10*n, 0.01+3*mu.s), nr = 10, byrow = TRUE)
x = rbind(x.1, x.2)
g = rep(0:1, each = 10)
res = multiseq(x, g)
plot(res$effect.mean, type = 'l')
plot(exp(res$effect.mean), type = 'l')
lines(3*mu.s-mu.s,col=2)
lines(3*mu.s/mu.s,col=2)
res = multiseq(x, g)
plot(exp(res$effect.mean), type = 'l')
lines(3*mu.s/mu.s,col=2)
plot(res$effect.mean, type = 'l')
lines(log(0.01+3*mu.s)-log(0.01+mu.s),col=2)
rd = rep(c(10000, 30000), each = 10)
res = multiseq(x, g, read.depth = rd)
plot(res$effect.mean, type = 'l')
lines(log(0.01+3*mu.s)-log(0.01+mu.s),col=2)
rd
sum(res$effect.mean)
multiseq
rowSums(x)
glm(matrix(c(rowSums(x),rd-rowSums(x)),nc=2),family="binomial")
glm(matrix(c(rowSums(x),rd-rowSums(x)),nc=2)~g,family="binomial")
multiseq
g = rep(0:1, each = 10)
rd = rep(c(1000, 3000), each = 10)
res = multiseq(x, g, read.depth = rd)
plot(res$effect.mean, type = 'l')
res = multiseq(x, g, read.depth = rd,lm.approx=TRUE)
plot(res$effect.mean, type = 'l')
res = multiseq(x, g, read.depth = rd,lm.approx=FLSE)
res = multiseq(x, g, read.depth = rd,lm.approx=FALSE)
plot(res$effect.mean, type = 'l')
glm(matrix(c(rowSums(x),rd-rowSums(x)),nc=2)~g,family="binomial")
summary(glm(matrix(c(rowSums(x),rd-rowSums(x)),nc=2)~g,family="binomial"))
rowSums(x)/rd
?glm
summary(glm(matrix(c(rowSums(x),rd,nc=2)~g,family="binomial"))
)
summary(glm(matrix(c(rowSums(x),rd),nc=2)~g,family="binomial"))
x.1 = matrix(rpois(10*n, 0.01+mu.s), nr = 10, byrow = TRUE)
x.2 = matrix(rpois(10*n, 0.03+3*mu.s), nr = 10, byrow = TRUE)
x = rbind(x.1, x.2)
g = rep(0:1, each = 10)
rd = rep(c(1000, 3000), each = 10)
res = multiseq(x, g, read.depth = rd)
plot(res$effect.mean, type = 'l')
res = multiseq(x, g)
plot(res$effect.mean, type = 'l')
lines(log(0.03+3*mu.s)-log(0.01+mu.s),col=2)
x.1 = matrix(rpois(10*n, 0.01+mu.s), nr = 10, byrow = TRUE)
x.2 = matrix(rpois(10*n, 0.03+3*mu.s), nr = 10, byrow = TRUE)
x = rbind(x.1, x.2)
g = rep(0:1, each = 10)
rd = rep(c(1000, 3000), each = 10)
res = multiseq(x, g)
plot(res$effect.mean, type = 'l')
lines(log(0.03+3*mu.s)-log(0.01+mu.s),col=2)
res = multiseq(x, g,read.depth=rd)
plot(res$effect.mean, type = 'l')
tt=matrix((12,1,36,3),nr=2)
tt=matrix(c(12,1,36,3),nr=2)
tt
glm.approx(tt,lm.approx=FALSE)
glm.approx(tt,lm.approx=TRUE)
tt=matrix(c(12,1,60,3),nr=2)
glm.approx(tt,lm.approx=TRUE)
glm.approx(tt,lm.approx=FALSE)
tt=matrix(c(2,1,6,3,12,1,60,3),nr=4)
glm.approx(tt,g=c(0,0,1,1),lm.approx=FALSE)
glm.approx(tt,g=c(0,0,1,1),lm.approx=TRUE)
tt=matrix(c(2,1,6,3,12,1,36,3),nr=4)
glm.approx(tt,g=c(0,0,1,1),lm.approx=TRUE)
glm.approx(tt,g=c(0,0,1,1),lm.approx=FALSE)
glm.approx(tt~c(0,0,1,1),family="binomial")
glm(tt~c(0,0,1,1),family="binomial")
tt=matrix(c(2,1,6,3,12,1,12,3),nr=4)
glm.approx(tt,g=c(0,0,1,1),lm.approx=FALSE)
glm.approx(tt,g=c(0,0,1,1),lm.approx=TRUE)
tt=matrix(c(2,1,6,3,12,1,60,3),nr=4)
glm.approx(tt,g=c(0,0,1,1),lm.approx=FALSE)
glm.approx(tt,g=c(0,0,1,1),lm.approx=TRUE)
runif(100)
runif(100,0.4)>0.5
4*4*500
4*4*15000
4*4*10000
48000*1.45
50000*1.45
79000/82000
runif(1)
mean(runif(10))
mean(runif(100))
mean(runif(1000))
mean(runif(10000))
mean(runif(100000))
mean(runif(1000000))
runif(1)
mean(runif(10))
mean(runif(100))
mean(runif(1000))
mean(runif(10000))
mean(runif(100000))
mean(runif(1000000))
library(motorcycle)
400/14000
2000/47000
2000/50000
function(k,t)=exp(-k*t)/sum(exp(-(1:6)*t))
test = function(k,t) exp(-k*t)/sum(exp(-(1:6)*t))
test(1,10000)
test(1,1000)
test(1,100)
test(2,100)
test(3,100)
test(4,100)
test(5,100)
test(6,100)
1200*7/840
18000/500
18000/500/5
18000/450/5
test=1:3
test[-1]
test[1:-1]
test[1:3]
34887+8759+2800
2060+100
2160*0.3
648*18
log2(log(1024))
library(ebayesthresh)
library(EBayesThresh)
library(EbayesThresh)
?ebayesthresh.wavelet
library(devtools)
install_github("stephens999/ashr", ref = "dd8f444f2729e864056fcddff274611702f5d58b")
library(smash)
time_em = matrix(0, nr = 10, nc = 2)
time_squarem = matrix(0, nr = 10, nc = 2)
time_ip = matrix(0, nr = 10, nc = 2)
sd = 2
for(i in 1:10){
b = rnorm(100000, sd = sd)
time_em[i, ] = system.time(ash(b, 1, optmethod = "mixEM"))[1:2]
time_squarem[i, ] = system.time(ash(b, 1, optmethod = "cxxMixSquarem"))[1:2]
time_ip[i, ] = system.time(ash(b, 1, optmethod = "mixIP"))[1:2]
}
summary(time_em[, 1])
summary(time_squarem[, 1])
summary(time_ip[, 1])
time_em = matrix(0, nr = 10, nc = 2)
time_squarem = matrix(0, nr = 10, nc = 2)
time_ip = matrix(0, nr = 10, nc = 2)
sd = 0.01
for(i in 1:10){
b = rnorm(100000, sd = sd)
time_em[i, ] = system.time(ash(b, 1, optmethod = "mixEM"))[1:2]
time_squarem[i, ] = system.time(ash(b, 1, optmethod = "cxxMixSquarem"))[1:2]
time_ip[i, ] = system.time(ash(b, 1, optmethod = "mixIP"))[1:2]
}
summary(time_em[, 1])
summary(time_squarem[, 1])
summary(time_ip[, 1])
?strptime
tt = "1992Jan12"
pattern = "[:digit:]+[:alpha:]+[:digit:]+"
pattern = "([:digit:]+)([:alpha:]+)([:digit:]+)"
gsub(pattern, "\\1-\\2-\\3", tt)
pattern = "([:digit:])([:alpha:])([:digit:])"
gsub(pattern, "\\1-\\2-\\3", tt)
?gsub
gsub(pattern, "\\1 \\2 \\3", tt)
pattern = "([0-9])([a-z])([0-9])"
gsub(pattern, "\\1 \\2 \\3", tt)
pattern = "([[:digit:]]+)([[:alpha:]]+)([[:digit:]]+)"
gsub(pattern, "\\1 \\2 \\3", tt)
gsub(pattern, "\\1-\\2-\\3", tt)
tt = rep(tt, 2)
gsub(pattern, "\\1-\\2-\\3", tt)
library(devtools)
install_github("zrxing/smash")
setwd("D:/Grad School/GitHub/ashwave/intro")
smash:::var.smooth
spike.f=function(x) (0.75*exp(-500*(x-0.23)^2)+1.5*exp(-2000*(x-0.33)^2)+3*exp(-8000*(x-0.47)^2)+2.25*exp(-16000*(x-0.69)^2)+0.5*exp(-32000*(x-0.83)^2))
n=1024
t=1:n/n
mu.s=spike.f(t)
mu.t=(1+mu.s)/5
##signal to noise ratio
rsnr=sqrt(1)
##variance functions
var1=rep(1,n)
var2=(0.0001+4*(exp(-550*(t-0.2)^2)+exp(-200*(t-0.5)^2)+exp(-950*(t-0.8)^2)))/1.35
sigma.ini=sqrt(var2)
sigma.t=sigma.ini/mean(sigma.ini)*sd(mu.t)/rsnr^2
set.seed(327)
X.s=matrix(rnorm(10*n,mu.t,sigma.t),nrow=10,byrow=TRUE)
x = X.ss[8,]
x = X.s[8,]
ashsmooth.gaus(x, v.est = TRUE)
library(smah)
library(smash)
ashsmooth.gaus(x, v.est = TRUE)
ti.thresh(x, method = "smash")
ti.thresh(x, method = "smash")
